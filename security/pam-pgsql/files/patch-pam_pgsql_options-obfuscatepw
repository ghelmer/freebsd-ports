--- src/pam_pgsql_options.c.ORIG	2013-08-26 17:38:07.000000000 -0500
+++ src/pam_pgsql_options.c	2013-08-26 17:42:40.000000000 -0500
@@ -18,6 +18,78 @@
 #include "pam_pgsql.h"
 #include "pam_pgsql_options.h"
 
+/*
+ * Table for converting a base 64-encoded string to a binary string.
+ */
+static uint32_t base64_rev_table[] = {
+/*                                                              */
+  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+/*                                                              */
+  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+/*                                            +               / */
+  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 62,  0,  0,  0, 63,
+/*0   1   2   3   4   5   6   7   8   9               =         */
+ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,  0,  0,  0,  0,  0,  0,
+/*    A   B   C   D   E   F   G   H   I   J   K   L   M   N   O */
+  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
+/*P   Q   R   S   T   U   V   W   X   Y   Z                     */
+ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,  0,  0,  0,  0,  0,
+/*    a   b   c   d   e   f   g   h   i   j   k   l   m   n   o */
+  0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+/*p   q   r   s   t   u   v   w   x   y   z                     */
+ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,  0,  0,  0,  0,  0
+};
+
+/*
+ * Convert the base64-encoded string in src to an unsigned binary
+ * string in dst and return the number of bytes in the destination
+ * string.
+ * There must be sufficient room in dst to hold
+ * ((strlen(src) + 1) * 3 / 4) plus the terminating '\0'.
+ */
+static int
+from_base64(const char *src, u_char *dst)
+{
+  uint32_t output;
+  int in_len;
+  int out_len;
+  int i, j;
+
+  in_len = strlen(src);
+  out_len = 0;
+  for (i = 0; i < in_len; i += 4)
+    {
+      output = 0;
+      for (j = 0; j < 4; j++)
+	{
+	  output <<= 6;
+	  if (src[i + j] > 0)
+	    {
+	      output |= base64_rev_table[(int)src[i + j]];
+	    }
+	  if (src[i + j] == 0)
+	    {
+	      /* Premature end of input. */
+	      break;
+	    }
+	}
+      while (j < 3)
+	{
+	  /* Shift output left to recover from premature end of input. */
+	  output <<= 6;
+	  j++;
+	}
+
+      /* Convert three-byte integer into three consecutive bytes. */
+      *dst++ = (u_char)((output >> 16) & 0xff);
+      *dst++ = (u_char)((output >> 8) & 0xff);
+      *dst++ = (u_char)(output & 0xff);
+      out_len += 3;
+    }
+  *dst++ = '\0';
+  return out_len;
+}
+
 static void
 read_config_file(modopt_t *options)
 {
@@ -93,7 +165,14 @@
             	options->sslmode = strdup(val);
 
 			} else if(!strcmp(buffer, "password")) {
-				options->passwd = strdup(val);
+				char passwd[strlen(val) + 1];
+
+				if (val[0] == '$' && val[1] == '$') {
+					from_base64(val + 2, (u_char *)passwd);
+				} else {
+					strlcpy(passwd, val, sizeof(passwd));
+				}
+				options->passwd = strdup(passwd);
 			} else if(!strcmp(buffer, "user_column")) {
 				options->column_user = strdup(val); 
 			} else if(!strcmp(buffer, "pwd_column")) {
